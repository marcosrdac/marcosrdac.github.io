<!doctype html>
<html>

  <head>
    <meta charset="utf-8">
    <!--<meta name="viewport"     content="width=device-width, initial-scale=1.0">-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=0">
    <meta name="author"       content="Marcos Reinan de Assis Conceição">
    <meta name="Description"  content="">
    <title>Marcos Conceição</title>
    <!-- CSS -->
    <link href="../../style/style.css" rel="stylesheet" media="screen, projection">
    <!-- Scripts -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>


  <body>

    <header class="site-header">
    <a href="../../index.html"><h1>Marcos</h1><h1>Conceição</h1></a>
    </header>


    <nav>
      <ul>
        <li><a href="../../content/portfolio.html">portefólio</a></li>
        <li><a href="../../content/services.html">serviços_oferecidos</a></li>
        <li><a href="../../content/contact.html">contato</a></li>
        <li><a href="../../content/about.html">sobre</a></li>
        <li><a href="../../content/blog.html">blog</a></li>
      </ul>
    </nav>


    <div class="page-container">
      <main>
        <header class="page-header">blog</header>

<article>
<header>
<h1><a id='post_title' href='20200310_propper_renaming_for_lf.html'>20200310 Proper renaming for LF</a></h1>
<p>Prepend, append, change extension and more</p>
</header>
<p>[20200803 Disclaimer] I&#8217;ll probably post a new version for the bulk-rename part soon and link it here.</p>

<p>I&#8217;ve definitely changed to LF file manager, but I still wanted the renaming power I had with other TUI file managers, like ranger&#8217;s and VIFM&#8217;s &#8220;I&#8221;, &#8220;A&#8221; and &#8220;a&#8221; mappings, or their &#8220;bulk-rename&#8221; function. So today I&#8217;m going to show you how to get those functionalities in LF.</p>

<h2>rename</h2>

<p>I&#8217;ve written this on my <code>lfrc</code> (inside <code>$HOME/.config/lf/</code>):</p>

<pre><code>cmd rename %{{
  base="$(dirname "$f")"
  srcfn=$(basename -- "$f")
  srcext="${srcfn##*.}"
  srcfn="$(basename "$f" ".$srcext")"
  srcdot="" &amp;&amp; [ ! -z $srcext ] &amp;&amp; srcdot="."

  case $1 in
    -n)  # filename_only
      dst="$base/$1$srcdot$srcext" ;;
    -e)  # extension_only
      dst="$base/$srcfn$srcdot$1" ;;
    *)   # full rename
      dst="$base/$1" ;;
  esac

  please=''
  for path in $f $dst
  do
    [ ! -w $(dirname "$path") ] &amp;&amp; please='sudo' &amp;&amp; break
  done
  [ $# -eq 0 ] &amp;&amp; echo "Destination not given." &amp;&amp; exit 1
  [ -e "$dst" ] &amp;&amp;
    printf "  Not renamed: "$dst" exists." ||
    $please mv "$f" "$dst"
}}
</code></pre>

<p>It is a rename function for the current file your cursor points to. Use it yourself: inside LF, type the following while pointing to &#8220;somefile.png":</p>

<div class="codehilite"><pre><span></span><code><span class="p">:</span>rename someanotherfile.png
</code></pre></div>

<p>Press enter, and now &#8220;somefile.png&#8221; is called someanotherfile.png&#8221;.</p>

<p>With <code>-n</code> option for rename, as in <code>:rename -n newname</code>, it just renames the filename, without extension. In the other hand, with the <code>-e</code> option, as in <code>:rename -e jpg</code>, it just changes the file extension to &#8220;jpg&#8221;. Anyway, options are really just fancy stuff. Look at how we are going to use this function in our mappings:</p>

<div class="codehilite"><pre><span></span><code># unmap <span class="k">c</span>
map <span class="k">c</span>
# <span class="k">make</span> cW push <span class="s2">&quot;:rename &quot;</span> into <span class="k">lf</span>
map cW &amp;<span class="k">lf</span> <span class="p">-</span>remote <span class="s2">&quot;send $id push :rename&lt;space&gt;&quot;</span>
</code></pre></div>

<p>What the third line above does is: whenever <code>cW</code> is pressed from LF, user is prompted with our rename function. This approach is certainly useful, but it turns out that LF freezes a little when &#8220;:&#8221; is pushed, as it is leaving normal mode and entering command mode. For it being frozen, sometimes the next character after &#8220;:&#8221; is not typed and we end up with <code>:ename -n</code> after pressing &#8220;cW&#8221; at a file&#8230; So, to avoid it, we can send two push commands to lf:
  1. one for sending just &#8220;:&#8221;;
  2. another one for sending the rest of the text.</p>

<p>I created another command to push these vim-like renaming commands to screen, which is called &#8220;vim-rename&#8221;. Our final polished mappings become:</p>

<pre><code>map c

map a  vim-rename append word
map I  vim-rename prepend word
map A  vim-rename append WORD
map C  vim-rename change WORD
map cW vim-rename change WORD
map cw vim-rename change word
map ce vim-rename change extension


cmd vim-rename &amp;{{
  # entering command mode
  lf -remote "send $id push :"
  # setting variables
  fn="$(basename $f)"
  name="${fn%.*}"
  [ $(echo "$fn" | grep "\." 2&gt;/dev/null) ] &amp;&amp; dot='.' &amp;&amp; ext="${fn##*.}"
  # reading options
  case "$@" in
    'change WORD') fn='' ;;
    'change word')
      fn=$(printf "$dot$ext")
      go_left=0 &amp;&amp; [ ! -z $dot ] &amp;&amp; go_left=$(echo "$ext" | wc -c)
      move="$(awk 'BEGIN{ for(c=0; c&lt;'$go_left'; c++) printf "&lt;left&gt;" }')"
      ;;
    'prepend word')
      go_right=$(echo 'rename' | wc -c)
      move="&lt;home&gt;$(awk 'BEGIN{ for(c=0;c&lt;'$go_right';c++) printf "&lt;right&gt;" }')"
      ;;
    'append word')
      go_left=0
      [ ! -z $dot ] &amp;&amp; go_left=$(echo "$ext" | wc -c)
      move="$(awk 'BEGIN{ for (c=0; c&lt;'$go_left'; c++) printf "&lt;left&gt;" }')"
      ;;
    'change extension')
      fn="$name$dot"
      ;;
    'append WORD') ;;
  esac
  lf -remote "send $id push $(echo "rename $fn$move" | sed 's/\s/&lt;space&gt;/g')"
}}
</code></pre>

<p>Now:</p>

<ul>
<li><strong>A</strong>: &#8220;append WORD&#8221; &#8212; prompts filename and puts cursor at the end of it;</li>
<li><strong>I</strong>: &#8220;prepend word&#8221; &#8212; prompts filename and puts cursor at it&#8217;s begining</li>
<li><strong>a</strong>: &#8220;append word&#8221; &#8212; prompts filename and puts cursor right before the first &#8220;.&#8221; (before extension);</li>
<li><strong>cw</strong>: &#8220;change word&#8221; &#8212; clears filename and puts cursof before extension (and dot, if existent);</li>
<li><strong>ce</strong>: &#8220;change extension&#8221; &#8212; clears extension and puts cursof after filename (and dot, if existent); and</li>
<li><strong>cW</strong> and <strong>C</strong>: &#8220;change WORD&#8221; &#8212; clear prompt for new filename.</li>
</ul>

<h2>bulk-rename</h2>

<p>bulk-rename here reads to &#8220;rename various files in a text editor&#8221;.</p>

<p>My code for this functionality is inpired by @EmmChriss&#8217;s response at <a href="https://github.com/gokcehan/lf/issues/149">github/gokcehan/lf/issues/149</a>. It has grown a bit, so I&#8217;ll tell you why you should use it first:</p>

<ol>
<li>You can rename various files in the program you&#8217;ve set for $EDITOR;</li>
<li>Have you ever wanted to rename both a movie and its subtitle to the same name but not to bother with their extensions in the process? Here you can bulk-rename without extension (and the task easily becomes as simple as &#8220;yypGddZZ&#8221; at VIM screen). This is done by using <code>-n</code> option.</li>
<li>Have you ever wanted to transform that bunch of free note text files into <code>.md</code>&#8217;s? You can rename just extensions! The option for this is <code>-e</code>.</li>
<li>You can also rename including all filepath (using option <code>-A</code>);</li>
</ol>

<p>Running <code>:bulk-rename</code> function in LF will take items in selection and show their names for edition in your text editor. If there are no items selected, all the current directory files are to be renamed, instead.</p>

<p>Everything you need to do is sign a pact by adding this to your <code>lfrc</code>:</p>

<pre><code>cmd bulk-rename ${{
  case $1 in
    # do not query extensions for renaming
    -n) mode="no-exts" ;;
    # only rename extensions
    -e) mode="only-exts" ;;
    # rename entire filepaths
    -A) mode="all-path" ;;
    # else, just rename filenames
  esac
  # make tmp files
  oldnames=$(mktemp /tmp/lf-bulk-oldnames.XXXXXXXXXX)
  newnames=$(mktemp /tmp/lf-bulk-newnames.XXXXXXXXXX)
  if [ "$mode" != "all-path" ]
  then
    dirnames=$(mktemp /tmp/lf-bulk-dirnames.XXXXXXXXXX)
    aux=$(mktemp /tmp/lf-bulk-aux.XXXXXXXXXX)
  fi
  # query selected files or all files in directory
  if [ -n "$fs" ]
  then
    index="$fs"
  else
    index="$(ls $(dirname "$f"))"
  fi
  # separate and save useful variables in files
  for path in $index
  do
    dir="$(dirname "$path")"
    fullfilename=$(basename -- "$path")
    filename="${fullfilename%.*}"  # must be here
    ext="" &amp;&amp; [ $(echo $fullfilename | grep "\." 2&gt;/dev/null) ] &amp;&amp; ext="${fullfilename##*.}"

    case "$mode" in
      "all-path") echo "$(realpath "$path")" &gt;&gt; $oldnames ;;
      "no-exts")
        echo "$filename" &gt;&gt; $oldnames
        [ "$ext" != "" ] &amp;&amp; ext=".$ext"
        echo "$ext" &gt;&gt; $aux
        ;;
      "only-exts")
        echo "$ext" &gt;&gt; $oldnames
        echo $filename &gt;&gt; $aux
        ;;
      "") echo "$fullfilename" &gt;&gt; $oldnames ;;
    esac
    [ "$mode" != "all-path" ] &amp;&amp; echo "$dir" &gt;&gt; $dirnames
  done
  cp $oldnames $newnames
  # interact with user
  $EDITOR $newnames
  # run mv on each path if they were modified
  n=$(cat $oldnames | wc -l)
  if [ $(cat $newnames | wc -l) -eq $n ]
  then
    counter=1
    while [ $counter -le $((n+1)) ]
    do
      case $mode in
        "no-exts")
          dir="$(cat $dirnames | sed "${counter}q;d")"
          old="$(cat $oldnames | sed "${counter}q;d")"
          new="$(cat $newnames | sed "${counter}q;d")"
          ext="$(cat $aux      | sed "${counter}q;d")"
          old="$dir/$old$ext" ; new="$dir/$new$ext"
        ;;
        "all-path")
          old="$(cat $oldnames | sed "${counter}q;d")"
          new="$(cat $newnames | sed "${counter}q;d")"
        ;;
        "only-exts")
          old="$(cat $oldnames | sed "${counter}q;d")"
          new="$(cat $newnames | sed "${counter}q;d")"
          filename="$(cat $aux | sed "${counter}q;d")"
          echo $old $new
          [ "$old" != "" ] &amp;&amp; old=".$old"
          [ "$new" != "" ] &amp;&amp; new=".$new"
          old="$dir/$filename$old"
          new="$dir/$filename$new"
        ;;
        *)
          dir="$(cat $dirnames | sed "${counter}q;d")"
          old="$(cat $oldnames | sed "${counter}q;d")"
          new="$(cat $newnames | sed "${counter}q;d")"
          old="$dir/$old" ; new="$dir/$new"
        ;;
      esac
      counter=$(($counter+1))
      [ "$old" = "$new" ] &amp;&amp; continue
      [ -e "$new" ] &amp;&amp; echo "File exists: $b" &amp;&amp; continue
      # check write permission
      please=''
      for path in $old $new
      do
        [ ! -w $(dirname "$path") ] &amp;&amp; please='sudo' &amp;&amp; break
      done
      $please mv "$old" "$new"
    done
  else
    echo "Number of filenames differ."
  fi

  # removing tmp files
  rm $oldnames $newnames
  if [ "$mode" != "all-path" ]
  then
    rm $dirnames
    rm $aux
  fi
}}
</code></pre>

<p>I hope you enjoy my codes!</p>

</article>
      </main>

      <aside>
        <header class="page-header">author</header>
        <figure>
          <img id=author src="../../pictures/me.gif" title="me" alt="photo of me" width="100%">
          <figcaption>marcosrdac</figcaption>
        </figure>
        <p>Marcos Conceição.</p>
        <p>Apaixonado por Linux, machine learning e obras do David Lynch.</p>
        <p>Graduando em Geofísica pela UFBa.</p>
        <p>Técnico em Edificações pelo IFBa.</p>
      </aside>
    </div>


    <footer>
      <figure>
        <img src="../../pictures/footer_sky.gif" title="footer" alt="">
      </figure>
      <p>Marcos Conceição, 2019.</p>
    </footer>

  </body>
</html>
