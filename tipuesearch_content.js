var tipuesearch = {"pages":[{"title":"About","text":"In construction.","tags":"pages","url":"http://127.0.0.1:8000/pages/about.html","loc":"http://127.0.0.1:8000/pages/about.html"},{"title":"Contact","text":"E-mail: marcosrdac@gmail.com","tags":"pages","url":"http://127.0.0.1:8000/pages/contact.html","loc":"http://127.0.0.1:8000/pages/contact.html"},{"title":"Portfolio","text":"In construction.","tags":"pages","url":"http://127.0.0.1:8000/pages/portfolio.html","loc":"http://127.0.0.1:8000/pages/portfolio.html"},{"title":"Services","text":"In construction.","tags":"pages","url":"http://127.0.0.1:8000/pages/services.html","loc":"http://127.0.0.1:8000/pages/services.html"},{"title":"Making various functions in one only block of code","text":"Have you ever needed to create numerous very similar functions? Today I'm showing you how to do that thing you always wanted to do in pure julia: create various functions in a loop. Supose you want to create three functions in julia: \\(f(x)=x\\) , \\(g(x)=x&#94;2\\) and \\(h(x)=x&#94;3\\) . So you could workfully write: function f ( x ) return x end function g ( x ) return x &#94; 2 end function h ( x ) return x &#94; 3 end But I know, when you are about to write \"function\" for the second time, your thoughts sudenly start to bother you: \"man, there must be a way for me to do it efficiently...\". I'm glad to tell you that you would be right! Lets expand our objectives for 6 functions and do it without all this machine work! for func in ( : f , : g , : h , : i , : j , : k ) if func == : f E = 1 elseif func == : g E = 2 elseif func == : h E = 3 elseif func == : i E = 4 elseif func == : j E = 5 elseif func == : k E = 6 end quote function $ func ( x ) return x &#94;$ E end end |> eval end And you can then start using $k(x)$ to get $x&#94;6$. The downside Although you might think that our last code would then be slower at runtime, after all it's all super high level code, it will not. These definitions are run at parse time, before actual compilation. So, roughly speaking, the only downside is that compiling your code is going to take more time. For those who want to understand what's going on... we enter a loop block at line 1. One iteration is done for each of the symbols f, g, h, i, j, k. At each iteration, func is assigned to one of them. then we enter the if elseif block. Depending on the symbol we are working on, we define a constant value E, the exponent used in the function. the next block quote s the code that we actually want to run: the function definition. We make use of the symbols previously defined by interpolating their values. For that we make use of the \\$ operator. the end: all inside this quotation returns a block object and, by itself, does nothing. It only becomes code when put this result inside the eval function. I could indeed be done like this: eval ( quote function $ func ( x ) return x &#94;$ E end end ) but I think it's prettier to pipe the quotation end to the eval function with |> eval .","tags":"blog","url":"http://127.0.0.1:8000/making-various-functions-in-one-only-block-of-code.html","loc":"http://127.0.0.1:8000/making-various-functions-in-one-only-block-of-code.html"},{"title":"Proper renaming for LF","text":"[20200803 Disclaimer] I'll probably post a new version for the bulk-rename part soon and link it here. I've definitely changed to LF file manager, but I still wanted the renaming power I had with other TUI file managers, like ranger's and VIFM's \"I\", \"A\" and \"a\" mappings, or their \"bulk-rename\" function. So today I'm going to show you how to get those functionalities in LF. rename I've written this on my lfrc (inside $HOME/.config/lf/ ): cmd rename %{{ base=\"$(dirname \" $f \")\" srcfn=$(basename -- \" $f \") srcext=\" ${ srcfn ##*. } \" srcfn=\"$(basename \" $f \" \". $srcext \")\" srcdot=\"\" && [ ! -z $srcext ] && srcdot=\".\" case $1 in -n) # filename_only dst=\" $base /$1 $srcdot$srcext \" ;; -e) # extension_only dst=\" $base / $srcfn$srcdot $1\" ;; *) # full rename dst=\" $base /$1\" ;; esac please='' for path in $f $dst do [ ! -w $(dirname \" $path \") ] && please='sudo' && break done [ $# -eq 0 ] && echo \"Destination not given.\" && exit 1 [ -e \" $dst \" ] && printf \" Not renamed: \" $dst \" exists.\" || $please mv \" $f \" \" $dst \" }} It is a rename function for the current file your cursor points to. Use it yourself: inside LF, type the following while pointing to \"somefile.png\": : rename someanotherfile.png Press enter, and now \"somefile.png\" is called someanotherfile.png\". With -n option for rename, as in :rename -n newname , it just renames the filename, without extension. In the other hand, with the -e option, as in :rename -e jpg , it just changes the file extension to \"jpg\". Anyway, options are really just fancy stuff. Look at how we are going to use this function in our mappings: # unmap c map c # make cW push \":rename \" into lf map cW & lf - remote \"send $id push :rename<space>\" What the third line above does is: whenever cW is pressed from LF, user is prompted with our rename function. This approach is certainly useful, but it turns out that LF freezes a little when \":\" is pushed, as it is leaving normal mode and entering command mode. For it being frozen, sometimes the next character after \":\" is not typed and we end up with :ename -n after pressing \"cW\" at a file... So, to avoid it, we can send two push commands to lf: 1. one for sending just \":\"; 2. another one for sending the rest of the text. I created another command to push these vim-like renaming commands to screen, which is called \"vim-rename\". Our final polished mappings become: map c map a vim - rename append word map I vim - rename prepend word map A vim - rename append WORD map C vim - rename change WORD map cW vim - rename change WORD map cw vim - rename change word map ce vim - rename change extension cmd vim - rename & {{ # entering command mode lf - remote \"send $id push :\" # setting variables fn = \"$(basename $f)\" name = \"${fn%.*}\" [ $ ( echo \"$fn\" | grep \"\\.\" 2 >/ dev / null ) ] && dot = '.' && ext = \"${fn##*.}\" # reading options case \"$@\" in ' change WORD ' ) fn = '' ;; ' change word ' ) fn = $ ( printf \"$dot$ext\" ) go_left = 0 && [ ! - z $ dot ] && go_left = $ ( echo \"$ext\" | wc - c ) move = \"$(awk 'BEGIN{ for(c=0; c<'$go_left'; c++) printf \" < left > \" }')\" ;; ' prepend word ' ) go_right = $ ( echo ' rename ' | wc - c ) move = \"<home>$(awk 'BEGIN{ for(c=0;c<'$go_right';c++) printf \" < right > \" }')\" ;; ' append word ' ) go_left = 0 [ ! - z $ dot ] && go_left = $ ( echo \"$ext\" | wc - c ) move = \"$(awk 'BEGIN{ for (c=0; c<'$go_left'; c++) printf \" < left > \" }')\" ;; ' change extension ' ) fn = \"$name$dot\" ;; ' append WORD ' ) ;; esac lf - remote \"send $id push $(echo \" rename $ fn $ move \" | sed 's/\\s/<space>/g')\" }} Now: A : \"append WORD\" --- prompts filename and puts cursor at the end of it; I : \"prepend word\" --- prompts filename and puts cursor at it's begining a : \"append word\" --- prompts filename and puts cursor right before the first \".\" (before extension); cw : \"change word\" --- clears filename and puts cursof before extension (and dot, if existent); ce : \"change extension\" --- clears extension and puts cursof after filename (and dot, if existent); and cW and C : \"change WORD\" --- clear prompt for new filename. bulk-rename bulk-rename here reads to \"rename various files in a text editor\". My code for this functionality is inpired by @EmmChriss's response at github/gokcehan/lf/issues/149 . It has grown a bit, so I'll tell you why you should use it first: You can rename various files in the program you've set for $EDITOR; Have you ever wanted to rename both a movie and its subtitle to the same name but not to bother with their extensions in the process? Here you can bulk-rename without extension (and the task easily becomes as simple as \"yypGddZZ\" at VIM screen). This is done by using -n option. Have you ever wanted to transform that bunch of free note text files into .md 's? You can rename just extensions! The option for this is -e . You can also rename including all filepath (using option -A ); Running :bulk-rename function in LF will take items in selection and show their names for edition in your text editor. If there are no items selected, all the current directory files are to be renamed, instead. Everything you need to do is sign a pact by adding this to your lfrc : cmd bulk-rename ${ { case $ 1 in # do not query extensions for renaming - n ) mode = \"no-exts\" ;; # only rename extensions - e ) mode = \"only-exts\" ;; # rename entire filepaths - A ) mode = \"all-path\" ;; # else, just rename filenames esac # make tmp files oldnames = $ ( mktemp / tmp / lf - bulk - oldnames . XXXXXXXXXX ) newnames = $ ( mktemp / tmp / lf - bulk - newnames . XXXXXXXXXX ) if [ \"$mode\" != \"all-path\" ] then dirnames = $ ( mktemp / tmp / lf - bulk - dirnames . XXXXXXXXXX ) aux = $ ( mktemp / tmp / lf - bulk - aux . XXXXXXXXXX ) fi # query selected files or all files in directory if [ - n \"$fs\" ] then index = \"$fs\" else index = \"$(ls $(dirname \" $ f \"))\" fi # separate and save useful variables in files for path in $ index do dir = \"$(dirname \" $ path \")\" fullfilename = $ ( basename -- \"$path\" ) filename = \"${fullfilename%.* } \" # must be here ext=\"\" && [ $(echo $fullfilename | grep \"\\.\" 2>/dev/null) ] && ext=\" ${ fullfilename ##*. } \" case \" $mode \" in \"all-path\") echo \"$(realpath \" $path \")\" >> $oldnames ;; \"no-exts\") echo \" $filename \" >> $oldnames [ \" $ext \" != \"\" ] && ext=\". $ext \" echo \" $ext \" >> $aux ;; \"only-exts\") echo \" $ext \" >> $oldnames echo $filename >> $aux ;; \"\") echo \" $fullfilename \" >> $oldnames ;; esac [ \" $mode \" != \"all-path\" ] && echo \" $dir \" >> $dirnames done cp $oldnames $newnames # interact with user $EDITOR $newnames # run mv on each path if they were modified n=$(cat $oldnames | wc -l) if [ $(cat $newnames | wc -l) -eq $n ] then counter=1 while [ $counter -le $((n+1)) ] do case $mode in \"no-exts\") dir=\"$(cat $dirnames | sed \" ${ counter } q;d\")\" old=\"$(cat $oldnames | sed \" ${ counter } q;d\")\" new=\"$(cat $newnames | sed \" ${ counter } q;d\")\" ext=\"$(cat $aux | sed \" ${ counter } q;d\")\" old=\" $dir / $old$ext \" ; new=\" $dir / $new$ext \" ;; \"all-path\") old=\"$(cat $oldnames | sed \" ${ counter } q;d\")\" new=\"$(cat $newnames | sed \" ${ counter } q;d\")\" ;; \"only-exts\") old=\"$(cat $oldnames | sed \" ${ counter } q;d\")\" new=\"$(cat $newnames | sed \" ${ counter } q;d\")\" filename=\"$(cat $aux | sed \" ${ counter } q;d\")\" echo $old $new [ \" $old \" != \"\" ] && old=\". $old \" [ \" $new \" != \"\" ] && new=\". $new \" old=\" $dir / $filename$old \" new=\" $dir / $filename$new \" ;; *) dir=\"$(cat $dirnames | sed \" ${ counter } q;d\")\" old=\"$(cat $oldnames | sed \" ${ counter } q;d\")\" new=\"$(cat $newnames | sed \" ${ counter } q;d\")\" old=\" $dir / $old \" ; new=\" $dir / $new \" ;; esac counter=$(( $counter +1)) [ \" $old \" = \" $new \" ] && continue [ -e \" $new \" ] && echo \"File exists: $b \" && continue # check write permission please='' for path in $old $new do [ ! -w $(dirname \" $path \") ] && please='sudo' && break done $please mv \" $old \" \" $new \" done else echo \"Number of filenames differ.\" fi # removing tmp files rm $oldnames $newnames if [ \" $mode \" != \"all-path\" ] then rm $dirnames rm $aux fi }} I hope you enjoy my codes!","tags":"blog","url":"http://127.0.0.1:8000/proper-renaming-for-lf.html","loc":"http://127.0.0.1:8000/proper-renaming-for-lf.html"},{"title":"TUI file managers battle","text":"Since two years ago, I've tried some terminal file managers and ended up finding three of my taste. The first one was ranger . It conquered me for being controled in a vim-like style, having a vim-like config file, having 3 panes (the first showing the parent directory files, the middle one, the files at your directory, and the third, a preview of the selected folder/file), being able to show me pitures directly on the terminal via w3m (although it was not very stable), and also been written in Python , which was my first programming language! Then I perceived it was really a good piece of software, but this last \"advatage\" turned out to be a disgustful characteristic: anything written in Python is inherently slower than it might be. And ranger is really slow, sometimes as slow as a gui file browser. So I tried Vifm and loved it: it is written in C , that is a language that not only I comprehend, as it is usually refference in velocity marks. And Vifm is de facto way faster than ranger . I could also preview images here, both using w3m or, better, using ueberzug , that is much better (gets me no fickering or instabilities). Another thing I liked about Vifm was that its config files were even closer to vim 's than ranger 's were. Well, the only thing that annoyed me was its panes. You always open to directories at once and looks at them both in panes. It makes te screen a mess by default. You could hide the seccond, but, if you wanted to preview a file with a pager or anything, you would have to reopen it and transform that seccond pane into a preview pane. I didn't like it at all. So some time ago I've discovered LF . LF is basically ranger , but almost as fast as Vifm , as it is well written in Go . It has some advantages, though: you can create functions inside the config file, and you write it in shell script , not in Python (it has never made sense). Also, the overall advage is: it launches a daemon at the first time you launch the program. And what it means? It means you can copy a file at one instance of LF , open another one in another terminal or multiplexer section, and then paste the file there! It is just amazing, something I missed in my previous TUI file managers. The only current disavantage is: image previwing is still not easily solved. I'm trying to make it work, though! So I'll make them three be evaluated in a table: Atribute \\ File manager ranger vifm lf Velocity 3 10 9 Ease viewing of files 10 3 10 Integrated multple instances 0 0 10 Improvability 4 8 10 Vim-like 8 9 9 Image previews 5 8 0 Rounded Normalized total 6 7 9 Then I conclude with my criteria that LF is the most switable TUI file manager for users like me. It is a very extensible tool and I recommend you to check my lfrc --- the LF configuration file --- settings in my dotfiles at GitHub . For Arch users: both ranger and vifm are in Arch's official repositories. You can install LF from AUR.","tags":"blog","url":"http://127.0.0.1:8000/tui-file-managers-battle.html","loc":"http://127.0.0.1:8000/tui-file-managers-battle.html"},{"title":"monstro_sonolento","text":"hoje me vi um monstro cristão quero dizer que fui tentado por qualquer demônio porque quero ser cristão porque agora sofro muito quero me limpar por minha boca com entidades quero me limpar por minha boca com tratos e conversas quero desabar, pois vejo que é tudo tão egoico e me pergunto a um deus que destino ele guarda para mim em sua onisciência que destino tem um monstro? bem, para toda contingência não é apenas tautologia moral desta vez é deformação, malevolência é encarceramento em autodefesa cultivarei meu sofrimento irresponsável cultivarei para que ele me marque não quero limpar minha boca, senão com água muito menos com a ajuda deste papel","tags":"poem","url":"http://127.0.0.1:8000/monstro_sonolento.html","loc":"http://127.0.0.1:8000/monstro_sonolento.html"}]};